#!/usr/bin/env python
# -*- encoding: utf-8 -*-
#
# Compile Bemsh assembler source into object file.
# Invoke dispak simulator to run Bemsh.
# Produce an output image in binary format:
#   filename.obj
#
# Leave twree imtermediate files:
#   filename.b6     -- task file for dispak simulator
#   filename.lst    -- listing generated by Bemsh
#   filename.dump   -- dump of resulting object file
#
import sys, os, string, subprocess, struct

#
# Parse command line.
#
if len(sys.argv) < 2:
    print "Usage: bemsh-to-obj.py filename.bemsh"
    sys.exit(1)
input_name = sys.argv[1]
basename = os.path.splitext(input_name)[0]
#print "basename =", basename

#
# Open input file.
#
try:
    input_file = open(input_name)
except:
    print "%s: Cannot open input file" % input_name
    sys.exit(1)

#
# Read input file and generate a task file.
#
task_name = basename + ".b6"
task_file = open(task_name, "w")
task_file.write("""шифр 419999 зс5^
лен 67(2148)^
eeв1а3
*name %s
*bemsh
""" % basename)
for line in input_file.readlines():
    task_file.write(line.rstrip() + "\n")
task_file.write("""*to pe:27
*end file
``````
еконец
""")
task_file.close()

#
# Run dispak simulator.
#
dispak = subprocess.Popen('dispak --drum-dump=%s.dump %s.b6' % (basename, basename),
    shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

lst_file = open(basename + ".lst", "w")
nerrors = -1
for line in dispak.stdout.readlines():
    lst_file.write(line.rstrip() + "\n")

    # Find status: number of errors.
    line = line.decode('utf-8')
    if len(line) > 13 and line[:13] == u"ЧИСЛО ОШИБОК=":
        nerrors = int(line[13:17])
        print "nerrors =", nerrors
lst_file.close()

retval = dispak.wait()
#print "retval =", retval
if retval == 127:
    print "dispak: Command not found"
    lst_file.close()
    os.remove(basename + ".lst")
    sys.exit(1)
if retval != 0:
    print "dispak: Failed to invoke Bemsh assembler"
    sys.exit(1)
if nerrors != 0:
    print "dispak: Bemsh errors detected: see %s.lst for details" % basename
    sys.exit(1)

#
# Open the dump file.
#
try:
    dump_file = open(basename + ".dump")
except:
    print "%s.dump: Cannot open dump file" % basename
    sys.exit(1)

#
# Generate obj file.
#
obj_file = open(basename + ".obj", "w")
obj_file.write("BESM6\0")
for line in dump_file.readlines():
    #print line,
    n = line.find(" ")
    if n > 0:
        cmd = line[:n]
        if cmd == "с":
            # Word value, for example:
            # с 1423 1456 1403 2456 ; 03776
            word = line.split()
            if len(word) == 7 or len(word) == 4:
                addr = int(word[6 if len(word) == 7 else 3], 8)
                if addr >= 04000:
                    #print addr, word
                    a = int(word[1], 8) if len(word) == 7 else 0
                    b = int(word[2], 8) if len(word) == 7 else 0
                    c = int(word[3], 8) if len(word) == 7 else 0
                    d = int(word[4], 8) if len(word) == 7 else 0
                    print "%04o %04o %04o %04o" % (a, b, c, d)

                    f = d & 0xff
                    e = (d >> 8) | (c << 4 & 0xff)
                    d = c >> 4
                    c = b & 0xff
                    b = (b >> 8) | (a << 4 & 0xff)
                    a = a >> 4
                    #print "%05o: %02x %02x %02x %02x %02x %02x" % (addr, a, b, c, d, e, f)
                    obj_file.write(struct.pack(">BBBBBB", a, b, c, d, e, f))
obj_file.close()

print "File %s succesfully compiled into %s.obj" % (input_name, basename)
